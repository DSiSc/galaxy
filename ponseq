[1mdiff --git a/consensus/policy/bft/bft-core.go b/consensus/policy/bft/bft-core.go[m
[1mindex 9aaabce..605b253 100644[m
[1m--- a/consensus/policy/bft/bft-core.go[m
[1m+++ b/consensus/policy/bft/bft-core.go[m
[36m@@ -129,6 +129,35 @@[m [mfunc (instance *bftCore) receiveRequest(request *messages.Request) {[m
 	instance.digest = request.Payload.Header.MixDigest[m
 	instance.signature.addSignature(instance.local, signData)[m
 	instance.broadcast(msgRaw)[m
[32m+[m	[32mgo instance.waitResponse()[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfunc (instance *bftCore) waitResponse() {[m
[32m+[m	[32mlog.Warn("set timer with 5 second.")[m
[32m+[m	[32minstance.timer = time.NewTimer(5 * time.Second)[m
[32m+[m	[32mfor {[m
[32m+[m		[32mselect {[m
[32m+[m		[32mcase <-instance.timer.C:[m
[32m+[m			[32mlog.Info("loop response timeout.")[m
[32m+[m			[32msignatures, err := instance.maybeCommit()[m
[32m+[m			[32mif nil != err {[m
[32m+[m				[32mlog.Warn("maybe commit errors %s.", err)[m
[32m+[m			[32m}[m
[32m+[m			[32minstance.commit = true[m
[32m+[m			[32minstance.result <- signatures[m
[32m+[m			[32mreturn[m
[32m+[m		[32mcase <-instance.tunnel:[m
[32m+[m			[32mlog.Info("receive tunnel")[m
[32m+[m			[32msignatures, _ := instance.maybeCommit()[m
[32m+[m			[32mif len(signatures) == len(instance.peers) {[m
[32m+[m				[32minstance.commit = true[m
[32m+[m				[32minstance.result <- signatures[m
[32m+[m				[32mlog.Info("receive all response before timeout")[m
[32m+[m				[32mreturn[m
[32m+[m			[32m}[m
[32m+[m			[32mlog.Warn("get %d signatures of %d peers.", len(signatures), len(instance.peers))[m
[32m+[m		[32m}[m
[32m+[m	[32m}[m
 }[m
 [m
 func (instance *bftCore) receiveProposal(proposal *messages.Proposal) {[m
[36m@@ -240,74 +269,39 @@[m [mfunc signDataVerify(account account.Account, sign []byte, digest types.Hash) boo[m
 	return account.Address == address[m
 }[m
 [m
[31m-func (instance *bftCore) toCommit() {[m
[31m-	for {[m
[31m-		select {[m
[31m-		case <-instance.timer.C:[m
[31m-			log.Info("to commit timeout.")[m
[31m-			signatures, err := instance.maybeCommit()[m
[31m-			if nil != err {[m
[31m-				log.Error("maybe commit failed with error %s.", err)[m
[31m-			}[m
[31m-			instance.commit = true[m
[31m-			instance.result <- signatures[m
[31m-			instance.timer = nil[m
[32m+[m[32mfunc (instance *bftCore) receiveResponse(response *messages.Response) {[m
[32m+[m	[32mif !instance.commit {[m
[32m+[m		[32misMaster := instance.local.Extension.Id == instance.master[m
[32m+[m		[32mif !isMaster {[m
[32m+[m			[32mlog.Info("only master need to process response.")[m
 			return[m
[31m-		case <-instance.tunnel:[m
[31m-			log.Info("receive tunnel")[m
[31m-			signatures, _ := instance.maybeCommit()[m
[31m-			if len(signatures) == len(instance.peers) {[m
[31m-				instance.commit = true[m
[31m-				instance.result <- signatures[m
[31m-				log.Info("receive all response before timeout")[m
[31m-				instance.timer = nil[m
[31m-				return[m
[32m+[m		[32m}[m
[32m+[m		[32mif !bytes.Equal(instance.digest[:], response.Digest[:]) {[m
[32m+[m			[32mlog.Error("received response digest %x not in coincidence with reserved %x.",[m
[32m+[m				[32minstance.digest, response.Digest)[m
[32m+[m			[32mreturn[m
[32m+[m		[32m}[m
[32m+[m		[32mpeer := instance.peers[response.Account.Extension.Id][m
[32m+[m		[32mif !signDataVerify(peer, response.Signature, instance.digest) {[m
[32m+[m			[32mlog.Error("signature and response sender not in coincidence.")[m
[32m+[m			[32mreturn[m
[32m+[m		[32m}[m
[32m+[m		[32mif sign, ok := instance.signature.signMap[peer]; !ok {[m
[32m+[m			[32minstance.signature.addSignature(peer, response.Signature)[m
[32m+[m			[32mlog.Info("try to notify toCommit.")[m
[32m+[m			[32minstance.tunnel <- 1[m
[32m+[m			[32mlog.Info("response from %x as been committed success.", response.Account.Address)[m
[32m+[m		[32m} else {[m
[32m+[m			[32m// check signature[m
[32m+[m			[32mif !bytes.Equal(sign, response.Signature) {[m
[32m+[m				[32mlog.Error("receive a different signature from the same validator %x, which exists is %x, while response is %x.",[m
[32m+[m					[32mpeer.Address, sign, response.Signature)[m
 			}[m
[31m-			log.Warn("get %d signatures of %d peers.", len(signatures), len(instance.peers))[m
[32m+[m			[32mlog.Warn("receive duplicate signature from the same validator, ignore it.")[m
 		}[m
[31m-	}[m
[31m-}[m
[31m-[m
[31m-func (instance *bftCore) receiveResponse(response *messages.Response) {[m
[31m-	if nil == instance.timer {[m
[31m-		instance.timer = time.NewTimer(5 * time.Second)[m
[31m-	}[m
[31m-	if !instance.commit {[m
[31m-		log.Info("try to commit the response.")[m
[31m-		go instance.toCommit()[m
 	} else {[m
 		log.Info("response has be committed, ignore response from %x.", response.Account.Address)[m
[31m-		return[m
[31m-	}[m
[31m-[m
[31m-	isMaster := instance.local.Extension.Id == instance.master[m
[31m-	if !isMaster {[m
[31m-		log.Info("only master need to process response.")[m
[31m-		return[m
[31m-	}[m
[31m-	if !bytes.Equal(instance.digest[:], response.Digest[:]) {[m
[31m-		log.Error("received response digest %x not in coincidence with reserved %x.",[m
[31m-			instance.digest, response.Digest)[m
[31m-		return[m
[31m-	}[m
[31m-	peer := instance.peers[response.Account.Extension.Id][m
[31m-	if !signDataVerify(peer, response.Signature, instance.digest) {[m
[31m-		log.Error("signature and response sender not in coincidence.")[m
[31m-		return[m
[31m-	}[m
[31m-	if sign, ok := instance.signature.signMap[peer]; !ok {[m
[31m-		instance.signature.addSignature(peer, response.Signature)[m
[31m-		log.Info("try to notify toCommit.")[m
[31m-		instance.tunnel <- 1[m
[31m-	} else {[m
[31m-		// check signature[m
[31m-		if !bytes.Equal(sign, response.Signature) {[m
[31m-			log.Error("receive a different signature from the same validator %x, which exists is %x, while response is %x.",[m
[31m-				peer.Address, sign, response.Signature)[m
[31m-		}[m
[31m-		log.Warn("receive duplicate signature from the same validator, ignore it.")[m
 	}[m
[31m-	log.Info("response from %x as been committed success.", response.Account.Address)[m
 }[m
 [m
 func (instance *bftCore) ProcessEvent(e tools.Event) tools.Event {[m
[1mdiff --git a/consensus/policy/bft/bft-core_test.go b/consensus/policy/bft/bft-core_test.go[m
[1mindex 13aae03..22719c1 100644[m
[1m--- a/consensus/policy/bft/bft-core_test.go[m
[1m+++ b/consensus/policy/bft/bft-core_test.go[m
[36m@@ -158,6 +158,7 @@[m [mfunc TestBftCore_ProcessEvent(t *testing.T) {[m
 	bft.signature.addSignature(bft.peers[2], mockSignset[2])[m
 	bft.tolerance = uint8((len(bft.peers) - 1) / 3)[m
 	bft.digest = mockHash[m
[32m+[m	[32mgo bft.waitResponse()[m
 	go func() {[m
 		err = bft.ProcessEvent(mockResponse)[m
 		assert.Nil(t, err)[m
[36m@@ -388,6 +389,16 @@[m [mfunc TestBftCore_receiveResponse(t *testing.T) {[m
 	bft := NewBFTCore(mockAccounts[0], sigChannel)[m
 	assert.NotNil(t, bft)[m
 	bft.peers = mockAccounts[m
[32m+[m	[32mbft.digest = mockHash[m
[32m+[m	[32mresponse := &messages.Response{[m
[32m+[m		[32mAccount:   mockAccounts[1],[m
[32m+[m		[32mTimestamp: time.Now().Unix(),[m
[32m+[m		[32mDigest:    mockHash,[m
[32m+[m		[32mSignature: mockSignset[2],[m
[32m+[m	[32m}[m
[32m+[m	[32mbft.signature.addSignature(mockAccounts[0], mockSignset[0])[m
[32m+[m	[32mbft.signature.addSignature(mockAccounts[1], mockSignset[1])[m
[32m+[m	[32mgo bft.waitResponse()[m
 	monkey.Patch(signature.Verify, func(_ keypair.PublicKey, sign []byte) (types.Address, error) {[m
 		var address types.Address[m
 		if bytes.Equal(sign[:], mockSignset[0]) {[m
[36m@@ -404,18 +415,32 @@[m [mfunc TestBftCore_receiveResponse(t *testing.T) {[m
 		}[m
 		return address, nil[m
 	})[m
[31m-	bft.digest = mockHash[m
[31m-	response := &messages.Response{[m
[32m+[m	[32mbft.receiveResponse(response)[m
[32m+[m	[32mch := <-bft.result[m
[32m+[m	[32massert.Equal(t, 2, len(ch))[m
[32m+[m
[32m+[m	[32mresponse = &messages.Response{[m
[32m+[m		[32mAccount:   mockAccounts[2],[m
[32m+[m		[32mTimestamp: time.Now().Unix(),[m
[32m+[m		[32mDigest:    mockHash,[m
[32m+[m		[32mSignature: mockSignset[2],[m
[32m+[m	[32m}[m
[32m+[m	[32mgo bft.waitResponse()[m
[32m+[m	[32mbft.commit = false[m
[32m+[m	[32mbft.receiveResponse(response)[m
[32m+[m	[32mch = <-bft.result[m
[32m+[m	[32massert.Equal(t, len(mockSignset[:3]), len(ch))[m
[32m+[m
[32m+[m	[32mresponse = &messages.Response{[m
 		Account:   mockAccounts[3],[m
 		Timestamp: time.Now().Unix(),[m
 		Digest:    mockHash,[m
 		Signature: mockSignset[3],[m
 	}[m
[31m-	bft.signature.addSignature(mockAccounts[0], mockSignset[0])[m
[31m-	bft.signature.addSignature(mockAccounts[1], mockSignset[1])[m
[31m-	bft.signature.addSignature(mockAccounts[2], mockSignset[2])[m
[32m+[m	[32mgo bft.waitResponse()[m
[32m+[m	[32mbft.commit = false[m
 	bft.receiveResponse(response)[m
[31m-	ch := <-bft.result[m
[32m+[m	[32mch = <-bft.result[m
 	assert.Equal(t, len(mockSignset[:4]), len(ch))[m
 	monkey.Unpatch(signature.Verify)[m
 }[m
